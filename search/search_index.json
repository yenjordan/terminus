{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the FastAPI React Starter Documentation","text":"<p>This documentation provides a comprehensive guide to understanding, setting up, developing, and deploying projects based on the FastAPI React Starter template.</p> <p>This starter template is designed to provide a modern, full-featured foundation for building web applications with a Python (FastAPI) backend and a React frontend, leveraging best practices and popular tools.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Backend (FastAPI): Robust and efficient, featuring async SQLAlchemy, JWT authentication, role-based access control, structured logging, and more.</li> <li>Frontend (React 19): Modern React with TypeScript, Vite, Tailwind CSS, shadcn/ui components, client-side routing, and custom hooks.</li> <li>Dockerized Environment: Easy setup and consistent development/production environments using Docker Compose.</li> <li>Database Management: Integrated Alembic migrations for schema management.</li> <li>Automated Setup: Convenience scripts for quick environment preparation.</li> </ul>"},{"location":"#navigating-the-documentation","title":"Navigating the Documentation","text":"<p>To get started, explore the following sections:</p> <ul> <li>Initial Setup: Step-by-step instructions to get the project running on your local machine.</li> <li>Development Guide: Information on project structure, coding standards, running tests, and common development tasks for both backend and frontend.</li> <li>Make It Yours: Tips and instructions on how to customize this starter template for your own project needs.</li> <li>Deployment: Guidelines for deploying your application to production environments.</li> <li>Project Roadmap: An overview of planned features and future development for this starter template.</li> </ul> <p>We aim to keep this documentation up-to-date and helpful. If you find any issues or have suggestions, please feel free to contribute!</p> <p> </p>"},{"location":"deployment/","title":"Deployment Guide","text":"<p>This guide provides instructions for deploying the FastAPI React Starter application to a production environment. The primary method described uses Docker and Docker Compose.</p>"},{"location":"deployment/#1-deployment-overview","title":"1. Deployment Overview","text":"<p>The recommended way to deploy this application is using Docker Compose. This method packages the backend, frontend, and database into manageable services.</p> <p>For a robust production setup, you'll typically place a reverse proxy (like Nginx or Traefik) in front of the application to handle HTTPS, load balancing, and potentially serve static frontend assets more efficiently.</p>"},{"location":"deployment/#2-prerequisites","title":"2. Prerequisites","text":"<ul> <li>Server: A server (VPS, dedicated server, or cloud instance) running a Linux distribution.</li> <li>Docker &amp; Docker Compose: Ensure Docker and Docker Compose (v2 plugin) are installed on your server. Follow the official installation guides.</li> <li>Domain Name: A registered domain name pointing to your server's IP address.</li> <li>SSL Certificates: SSL certificates for your domain to enable HTTPS (e.g., from Let's Encrypt).</li> <li>Firewall: Configure your server's firewall to allow traffic on necessary ports (e.g., 80 for HTTP, 443 for HTTPS).</li> </ul>"},{"location":"deployment/#3-production-configuration","title":"3. Production Configuration","text":"<p>Before deploying, you must configure environment variables for production. It's highly recommended to use a separate <code>.env</code> file for production or manage these variables securely through your deployment environment.</p>"},{"location":"deployment/#31-root-env-file-for-docker-compose","title":"3.1. Root <code>.env</code> File (for Docker Compose)","text":"<p>Create or update the <code>.env</code> file in your project root on the server:</p> <pre><code># Database Configuration (ensure these are strong, unique credentials)\nDB_USER=your_prod_db_user\nDB_PASSWORD=your_prod_db_password\nDB_NAME=your_prod_db_name\n\n# Backend Production Settings (passed to backend service in docker-compose.yml)\nENVIRONMENT=production\nJWT_SECRET_KEY=generate_a_very_strong_random_secret_key # IMPORTANT! Change this!\nPROD_CORS_ORIGINS=[\"https://yourdomain.com\",\"https://www.yourdomain.com\"] # Your frontend domain(s)\n\n# Frontend Production Settings (passed to frontend service in docker-compose.yml)\nPROD_VITE_API_URL=https://yourdomain.com/api # URL of your backend API\n</code></pre> <p>Key Production Variables:</p> <ul> <li><code>DB_USER</code>, <code>DB_PASSWORD</code>, <code>DB_NAME</code>: Use strong, unique credentials for your production database.</li> <li><code>ENVIRONMENT=production</code>: Sets the application to run in production mode (affects logging, error handling, etc., as defined in <code>backend/app/config/config.py</code>).</li> <li><code>JWT_SECRET_KEY</code>: CRITICAL! This key is used to sign JWTs. It must be a long, random, and secret string. Do not use the development default. You can generate one using <code>openssl rand -hex 32</code>.</li> <li><code>PROD_CORS_ORIGINS</code>: A JSON-formatted string array of allowed origins for CORS. Replace <code>https://yourdomain.com</code> with your actual frontend domain(s).</li> <li><code>PROD_VITE_API_URL</code>: The public URL where your backend API will be accessible (e.g., if served under <code>/api</code> via a reverse proxy).</li> </ul>"},{"location":"deployment/#32-docker-compose-adjustments-for-production","title":"3.2. Docker Compose Adjustments for Production","text":"<p>It's best practice to have a production-specific Docker Compose file (e.g., <code>docker-compose.prod.yml</code>) or to modify the existing <code>docker-compose.yml</code> for production needs. Here are key changes to consider:</p> <ul> <li>Remove Development Volumes: For the <code>backend</code> and <code>frontend</code> services, remove the host-mounted volumes that map your local code into the container (e.g., <code>volumes: - ./backend:/app</code>). In production, the code should be copied into the image during the build process.</li> <li>Production Commands:<ul> <li>Backend: Change the <code>command</code> to use a production-grade ASGI server like Gunicorn with Uvicorn workers. Example:     <pre><code># In docker-compose.yml for backend service\ncommand: gunicorn -k uvicorn.workers.UvicornWorker -w 4 app.main:app --bind 0.0.0.0:8000\n</code></pre>     Adjust the number of workers (<code>-w 4</code>) based on your server's CPU cores.</li> <li>Frontend: The <code>command</code> should serve the built static assets or run a production Node.js server if applicable. If your <code>frontend/Dockerfile</code> builds static assets (e.g., into <code>/app/dist</code>), you might use a multi-stage Dockerfile with a lightweight web server like Nginx to serve these files. Alternatively, if <code>npm run build</code> creates a <code>dist</code> folder, and your <code>Dockerfile</code> copies it and <code>npm start</code> (or a similar command in <code>package.json</code>) serves it with a production-ready static server, that can also work.     If serving frontend static files via Nginx (either in the frontend container or a separate reverse proxy container), the frontend service in <code>docker-compose.yml</code> might not need to expose a port directly or could be simplified.</li> </ul> </li> <li>Environment Variables: Update the <code>environment</code> section in <code>docker-compose.yml</code> for <code>backend</code> and <code>frontend</code> services to use the production values defined in your root <code>.env</code> file:     <pre><code># backend service\nenvironment:\n  - DB_NAME=${DB_NAME}\n  - DB_USER=${DB_USER}\n  - DB_PASSWORD=${DB_PASSWORD}\n  - DB_HOST=postgres # Stays as the service name\n  - DB_PORT=5432\n  - CORS_ORIGINS=${PROD_CORS_ORIGINS}\n  - ENVIRONMENT=${ENVIRONMENT:-production} # Default to production\n  - JWT_SECRET_KEY=${JWT_SECRET_KEY}      # Passed from root .env\n\n# frontend service\nenvironment:\n  - VITE_API_URL=${PROD_VITE_API_URL} # Passed from root .env\n  # Add any other necessary production env vars for frontend build/runtime\n</code></pre></li> <li>Ports: Only expose ports that need to be accessed externally (typically via a reverse proxy, e.g., port 80 or 443). Internal service-to-service communication uses Docker's internal network.</li> </ul> <p>Example <code>docker-compose.prod.yml</code> (Illustrative - combine with your base <code>docker-compose.yml</code>):</p> <pre><code># docker-compose.prod.yml\nversion: '3.8'\n\nservices:\n  backend:\n    # Remove development volume mount if present in base file\n    # volumes: [] # Clears volumes from base file if using extends\n    command: gunicorn -k uvicorn.workers.UvicornWorker -w 4 app.main:app --bind 0.0.0.0:8000\n    environment:\n      - ENVIRONMENT=production\n      - CORS_ORIGINS=${PROD_CORS_ORIGINS}\n      - JWT_SECRET_KEY=${JWT_SECRET_KEY}\n    # Potentially remove port mapping if accessed via reverse proxy\n    # ports:\n    #   - \"8000:8000\"\n\n  frontend:\n    # Remove development volume mount\n    # volumes: []\n    # command: npm run start # Or command to serve built static files\n    environment:\n      - VITE_API_URL=${PROD_VITE_API_URL}\n    # Potentially remove port mapping\n    # ports:\n    #  - \"5173:5173\"\n\n# Ensure postgres_data volume is still defined as in the base docker-compose.yml\n# volumes:\n#   postgres_data:\n</code></pre> <p>To use multiple compose files: <code>docker compose -f docker-compose.yml -f docker-compose.prod.yml up --build -d</code></p>"},{"location":"deployment/#4-building-and-running-in-production","title":"4. Building and Running in Production","text":"<ol> <li>Transfer Project: Copy your project files (including your production-ready Dockerfiles and Docker Compose files) to your server.</li> <li>Create <code>.env</code> file: Create the root <code>.env</code> file on your server with production values as described above.</li> <li>Pull latest images (optional but good practice): <pre><code>docker compose pull # Pulls base images like postgres:17-alpine\n</code></pre></li> <li> <p>Build and Start Services: <pre><code># If using a single, modified docker-compose.yml\ndocker compose up --build -d\n\n# If using docker-compose.prod.yml to override/extend\ndocker compose -f docker-compose.yml -f docker-compose.prod.yml up --build -d\n</code></pre>     The <code>--build</code> flag ensures images are rebuilt. The <code>-d</code> flag runs services in detached mode.</p> </li> <li> <p>Database Migrations: The backend service is configured with <code>command: bash -c \"python manage.py run\"</code> which internally calls <code>migrate</code> before starting the app. If you change this command for production (e.g., to Gunicorn directly), ensure migrations are run as a separate step or as part of your container's entrypoint script before the main application starts.     <pre><code># Example of running migrations manually if needed\ndocker compose exec backend python manage.py migrate\n</code></pre></p> </li> </ol>"},{"location":"deployment/#5-data-persistence","title":"5. Data Persistence","text":"<p>The <code>docker-compose.yml</code> defines a named volume <code>postgres_data</code> for the PostgreSQL database. This ensures that your database data persists even if the <code>postgres</code> container is stopped or removed. Ensure this volume is properly managed and backed up as part of your server maintenance routine.</p>"},{"location":"deployment/#6-reverse-proxy-and-https-recommended","title":"6. Reverse Proxy and HTTPS (Recommended)","text":"<p>For production, it's highly recommended to use a reverse proxy like Nginx or Traefik.</p> <p>Benefits: *   HTTPS/SSL Termination: Handle SSL certificates and encrypt traffic. *   Load Balancing: (If you scale to multiple instances of your backend). *   Serving Static Files: Nginx is very efficient at serving static frontend assets. *   Custom Domain Names: Easily map your domain to the application. *   Security: Can add security headers, rate limiting, etc.</p> <p>General Setup with Nginx (Conceptual): 1.  Install Nginx on your server. 2.  Configure Nginx as a reverse proxy to forward requests to your Dockerized services:     *   Requests to <code>yourdomain.com/api/*</code> could go to the <code>backend</code> service (e.g., <code>http://localhost:8000</code>).     *   Requests to <code>yourdomain.com/*</code> could serve the static frontend assets (if built and served by Nginx) or go to the <code>frontend</code> service (e.g., <code>http://localhost:5173</code>). 3.  Set up SSL certificates (e.g., using Certbot with Let's Encrypt) for your domain in Nginx.</p> <p>Refer to Nginx or Traefik documentation for detailed configuration instructions.</p>"},{"location":"deployment/#7-deploying-documentation-mkdocs","title":"7. Deploying Documentation (MkDocs)","text":"<p>The <code>docs</code> service in <code>docker-compose.yml</code> serves the documentation.</p> <ol> <li>Ensure the <code>docs</code> service is included when you run <code>docker compose up</code>.</li> <li>If you have a reverse proxy, configure it to route traffic from a subdomain (e.g., <code>docs.yourdomain.com</code>) or a path (e.g., <code>yourdomain.com/project-docs/</code>) to the <code>docs</code> service (e.g., <code>http://localhost:8001</code>).</li> </ol> <p>Alternatively, you can build the MkDocs site into static HTML files and deploy them to any static hosting provider (e.g., GitHub Pages, Netlify, AWS S3):</p> <p><pre><code># From your local machine, in the project root\ndocker compose run --rm docs mkdocs build\n</code></pre> This will generate the static site in the <code>docs/site/</code> directory (or as configured in <code>mkdocs.yml</code>). You can then upload this <code>site</code> directory.</p>"},{"location":"deployment/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<ul> <li>Application Logs: Use <code>docker compose logs backend</code> and <code>docker compose logs frontend</code> to view application logs.</li> <li>Server Monitoring: Implement server-level monitoring for CPU, memory, disk space, and network traffic.</li> <li>Log Aggregation: For more robust logging, consider setting up a centralized logging solution (e.g., ELK stack, Grafana Loki, or a cloud provider's logging service).</li> </ul>"},{"location":"deployment/#9-cloud-provider-deployments","title":"9. Cloud Provider Deployments","text":"<p>While Docker Compose is excellent for single-server deployments, you might want to leverage managed cloud platforms like Google Cloud Run or AWS ECS for better scalability, reliability, and easier management.</p> <p>The <code>deployments/</code> directory in this project contains ready-to-use configuration files for these platforms.</p>"},{"location":"deployment/#91-google-cloud-run","title":"9.1. Google Cloud Run","text":"<p>Google Cloud Run is a serverless platform that automatically scales your containerized applications.</p> <ul> <li>Configuration File: <code>deployments/google-cloud/cloudbuild.yaml</code></li> <li>Method: This file is used with Google Cloud Build to automatically build your backend and frontend Docker images, push them to Google Container Registry (GCR), and deploy them as two separate services on Cloud Run.</li> </ul> <p>To Deploy: 1.  Prerequisites:     *   A Google Cloud Project with billing enabled.     *   The <code>gcloud</code> CLI installed and configured.     *   Cloud Build, Cloud Run, and Container Registry APIs enabled. 2.  Configure Substitutions: The <code>cloudbuild.yaml</code> uses substitution variables (e.g., <code>_REGION</code>, <code>_BACKEND_SERVICE_NAME</code>). You can set these directly in a Cloud Build trigger or when running the build manually. 3.  Set up a Trigger: In the Google Cloud Console, navigate to Cloud Build and create a trigger that points to your source code repository. Configure it to use the <code>deployments/google-cloud/cloudbuild.yaml</code> file. 4.  Push to Deploy: Pushing a commit to your configured branch will automatically trigger the build and deployment process.</p> <p>For detailed steps, refer to the Google Cloud Run documentation.</p>"},{"location":"deployment/#92-aws-elastic-container-service-ecs-with-fargate","title":"9.2. AWS Elastic Container Service (ECS) with Fargate","text":"<p>AWS ECS is a highly scalable container orchestration service. Fargate is a serverless compute engine for ECS, so you don't have to manage servers.</p> <ul> <li>Configuration Files:<ul> <li><code>deployments/aws/buildspec.yml</code>: For AWS CodeBuild to build and push images to ECR.</li> <li><code>deployments/aws/task-definitions/</code>: Contains JSON templates for the backend and frontend ECS task definitions.</li> </ul> </li> <li>Method:<ol> <li>AWS CodePipeline: Create a pipeline that uses your source repository (e.g., GitHub, AWS CodeCommit).</li> <li>Build Stage: Add a build stage that uses AWS CodeBuild with the <code>buildspec.yml</code> file. This will build your Docker images and push them to Amazon ECR.</li> <li>Deploy Stage: Add a deploy stage that uses the \"Amazon ECS\" action to deploy your services using the task definitions.</li> </ol> </li> </ul> <p>To Deploy: 1.  Prerequisites:     *   An AWS account.     *   The <code>aws</code> CLI installed and configured.     *   ECR repositories for your backend and frontend images.     *   An ECS cluster. 2.  Customize Task Definitions: Update the placeholder values (e.g., <code>&lt;YOUR_BACKEND_ECR_REPO_URI&gt;</code>, <code>&lt;YOUR_AWS_ACCOUNT_ID&gt;</code>) in the <code>*.json</code> task definition files. 3.  Set up CodePipeline: Follow the AWS documentation to create a pipeline that automates the build and deploy process from your repository to your ECS cluster.</p> <p>For detailed steps, refer to the AWS ECS User Guide.</p> <p>Deploying a web application involves many considerations. This guide provides a starting point for self hosting and two of the top cloud providers. Always adapt the configuration to your specific security and performance requirements. You have a way to go before you can deploy your project from this template, once you have reached a point where you can deploy your project reach out to the maintainer for assistance.</p>"},{"location":"development/","title":"Development Guide","text":"<p>This guide provides instructions and best practices for developing within the FastAPI React Starter project.</p>"},{"location":"development/#1-project-structure-overview","title":"1. Project Structure Overview","text":"<p>The project is organized into a <code>backend</code> (FastAPI) and a <code>frontend</code> (React) directory, along with a <code>docs</code> directory for this documentation and root-level configuration files.</p> <ul> <li><code>backend/</code>: Contains the FastAPI application.<ul> <li><code>app/</code>: Core application code (main app, config, db, routes, schemas, services, utils).</li> <li><code>requirements.txt</code>: Python dependencies.</li> <li><code>pyproject.toml</code>: Project metadata and tool configuration (e.g., Black).</li> <li><code>manage.py</code>: Script for database migrations and other management commands.</li> </ul> </li> <li><code>frontend/</code>: Contains the React application.<ul> <li><code>src/</code>: Core application code (components, features, hooks, layouts, etc.).</li> <li><code>package.json</code>: Node.js dependencies and scripts.</li> <li><code>vite.config.ts</code>: Vite build configuration.</li> <li><code>tailwind.config.js</code>: Tailwind CSS configuration.</li> </ul> </li> <li><code>docs/</code>: Project documentation (MkDocs).</li> <li><code>docker-compose.yml</code>: Defines the services for Docker.</li> <li><code>.pre-commit-config.yaml</code>: Configuration for pre-commit hooks.</li> </ul> <p>For a more detailed visual structure, refer to the <code>README.md</code> or the Project Overview.</p>"},{"location":"development/#2-backend-development-fastapi","title":"2. Backend Development (FastAPI)","text":""},{"location":"development/#key-directories","title":"Key Directories","text":"<ul> <li><code>app/main.py</code>: FastAPI application entry point.</li> <li><code>app/config/config.py</code>: Environment settings and logging configuration.</li> <li><code>app/db/</code>: Database connection (<code>database.py</code>) and SQLAlchemy models (<code>models.py</code>).</li> <li><code>app/routes/</code>: API endpoint definitions.</li> <li><code>app/schemas/</code>: Pydantic models for data validation and serialization.</li> <li><code>app/services/</code>: Business logic and service layer.</li> <li><code>app/utils/</code>: Utility functions (e.g., custom logger setup, though primary logging is in <code>config.py</code>).</li> </ul>"},{"location":"development/#linting-and-formatting","title":"Linting and Formatting","text":"<ul> <li>Black: Code formatting is enforced using Black. Configuration is in <code>pyproject.toml</code> (<code>line-length = 100</code>).<ul> <li>It's recommended to integrate Black into your IDE or run it manually before committing:     <pre><code># Navigate to backend directory\ncd backend\nblack .\n</code></pre></li> </ul> </li> <li>Pre-commit Hooks: Black is also run as a pre-commit hook (see section below).</li> <li>(Optional) Ruff/Flake8/MyPy: Consider adding Ruff (for linting and formatting, can replace Black/Flake8) or MyPy (for static type checking) for enhanced code quality. Add them to <code>requirements-dev.txt</code> and <code>.pre-commit-config.yaml</code>.</li> </ul>"},{"location":"development/#running-tests","title":"Running Tests","text":"<p>This backend is setup with pytest and coverage. To run tests, navigate to the backend directory and run:</p> <pre><code>cd backend\npytest\n</code></pre> <p>To run tests with coverage, navigate to the backend directory and run:</p> <pre><code>cd backend\npytest --cov=app\n</code></pre>"},{"location":"development/#database-migrations","title":"Database Migrations","text":"<p>The project uses Alembic for database migrations, managed via <code>manage.py</code>.</p> <ul> <li>Generate a new migration (after changing models): <pre><code># Ensure you are in the backend directory\ncd backend\npython manage.py makemigrations \"Your descriptive migration message\"\n</code></pre></li> <li>Apply migrations: <pre><code>python manage.py migrate\n</code></pre></li> <li>Check migration status: <pre><code>python manage.py db-status\n</code></pre></li> <li>Downgrade (revert) last migration: <pre><code>python manage.py downgrade\n</code></pre></li> <li>Reset database (development only - drops all tables and reapplies all migrations): <pre><code>python manage.py reset_db\n</code></pre></li> </ul>"},{"location":"development/#logging","title":"Logging","text":"<p>Structured logging is configured in <code>backend/app/config/config.py</code>. The main application logger can be imported and used as follows:</p> <pre><code>from app.config import logger\n\nlogger.info(\"This is an info message.\")\nlogger.error(\"This is an error message.\")\n</code></pre>"},{"location":"development/#adding-new-features","title":"Adding New Features","text":"<ol> <li>Models (<code>app/db/models.py</code>): Define or update SQLAlchemy models.</li> <li>Schemas (<code>app/schemas/</code>): Create Pydantic schemas for request/response validation and serialization.</li> <li>Services (<code>app/services/</code>): Implement the business logic.</li> <li>Routes (<code>app/routes/</code>): Define new API endpoints, using the services and schemas.</li> <li>Migrations: Generate and apply database migrations if models changed.</li> <li>Tests: Write tests for the new functionality.</li> </ol>"},{"location":"development/#3-frontend-development-react","title":"3. Frontend Development (React)","text":""},{"location":"development/#key-directories_1","title":"Key Directories","text":"<ul> <li><code>src/App.tsx</code>: Main React application component and router setup.</li> <li><code>src/components/</code>: Reusable UI components.<ul> <li><code>ui/</code>: shadcn/ui components.</li> </ul> </li> <li><code>src/features/</code>: Feature-specific modules (e.g., auth, health).</li> <li><code>src/hooks/</code>: Custom React hooks.</li> <li><code>src/layouts/</code>: Page layout components.</li> <li><code>src/lib/</code>: Utility functions and configurations (e.g., <code>utils.ts</code> for shadcn).</li> <li><code>src/routes/</code>: Page components rendered by React Router.</li> <li><code>src/types/</code>: TypeScript type definitions.</li> </ul>"},{"location":"development/#linting-formatting-and-type-checking","title":"Linting, Formatting, and Type Checking","text":"<ul> <li>Prettier: Code formatting is enforced using Prettier. It's configured to run via pre-commit hooks.<ul> <li>To format manually:     <pre><code># Navigate to frontend directory\ncd frontend\nnpm run format\n</code></pre></li> <li>To check formatting:     <pre><code>npm run format:check\n</code></pre></li> </ul> </li> <li>ESLint: (Consider adding ESLint for code quality and style rules if not already implicitly handled by Prettier/TypeScript setup).</li> <li>TypeScript: Static type checking is performed by TypeScript.<ul> <li>To type-check the project:     <pre><code># Navigate to frontend directory\ncd frontend\nnpm run typecheck\n</code></pre></li> </ul> </li> </ul>"},{"location":"development/#running-tests_1","title":"Running Tests","text":"<p>(Documentation on the testing framework (e.g., Vitest, React Testing Library) and how to run tests should be added here. This will be updated as tests for the frontend are added in the future.)</p>"},{"location":"development/#styling","title":"Styling","text":"<ul> <li>Tailwind CSS: Utility-first CSS framework used for styling. Configuration is in <code>frontend/tailwind.config.js</code>.</li> <li>shadcn/ui: Collection of beautifully designed, accessible, and customizable React components built with Radix UI and Tailwind CSS. Components are typically added via the shadcn/ui CLI and can be found in <code>src/components/ui/</code>.</li> </ul>"},{"location":"development/#adding-new-featurescomponents","title":"Adding New Features/Components","text":"<ol> <li>Define Types (<code>src/types/</code>): If new data structures are involved.</li> <li>Create Components (<code>src/components/</code> or <code>src/features/</code>): Develop new React components.</li> <li>Implement Hooks (<code>src/hooks/</code>): For reusable logic or data fetching.</li> <li>Add Routes (<code>src/App.tsx</code> or <code>src/routes/</code>): If new pages are needed.</li> <li>Style: Use Tailwind CSS classes and shadcn/ui components.</li> <li>Tests: Write tests for new components and logic.</li> </ol>"},{"location":"development/#4-working-with-docker-development","title":"4. Working with Docker (Development)","text":"<p>While developing, you might need to interact with the Docker containers:</p> <ul> <li>View logs for all services: <pre><code>docker compose logs -f\n</code></pre></li> <li>View logs for a specific service (e.g., backend): <pre><code>docker compose logs -f backend\n</code></pre></li> <li>Access a shell in a running container (e.g., backend): <pre><code>docker compose exec backend /bin/bash\n</code></pre></li> <li>Rebuild and restart a specific service (e.g., backend after changing dependencies): <pre><code>docker compose up --build -d backend\n</code></pre></li> <li>Stop all services: <pre><code>docker compose down\n</code></pre></li> </ul>"},{"location":"development/#5-pre-commit-hooks","title":"5. Pre-commit Hooks","text":"<p>The project uses pre-commit hooks managed by <code>pre-commit</code> to automatically lint and format code before committing. The configuration is in <code>.pre-commit-config.yaml</code>.</p> <p>Hooks include: *   <code>trailing-whitespace</code>: Removes trailing whitespace. *   <code>end-of-file-fixer</code>: Ensures files end with a single newline. *   <code>check-yaml</code>: Checks YAML files for syntax errors. *   <code>check-added-large-files</code>: Prevents committing large files. *   <code>black</code>: Formats Python code. *   <code>prettier</code>: Formats frontend code (JS, TS, JSON, CSS, Markdown).</p> <p>Setup: If you haven't already, install <code>pre-commit</code> and set up the hooks:</p> <p><pre><code># Install pre-commit (if not already installed, e.g., via pip or brew)\npip install pre-commit\n\n# Install the git hook scripts from the project root\npre-commit install\n</code></pre> Now, the hooks will run automatically on <code>git commit</code>.</p>"},{"location":"development/#6-debugging-tips","title":"6. Debugging Tips","text":"<ul> <li>Backend (FastAPI):<ul> <li>Use <code>print()</code> statements or the configured <code>logger</code>.</li> <li>FastAPI's interactive debugger (if an error occurs in development mode).</li> <li>Set breakpoints if using an IDE with debugging capabilities (e.g., VS Code).</li> <li>Check <code>docker compose logs backend</code> for errors if running via Docker.</li> </ul> </li> <li>Frontend (React):<ul> <li>Use browser developer tools (console, network tab, React DevTools extension).</li> <li><code>console.log()</code> statements.</li> <li>React DevTools for inspecting component hierarchy, state, and props.</li> <li>Check <code>docker compose logs frontend</code> for build errors if running via Docker.</li> </ul> </li> </ul> <p>This development guide should help you get started. Happy coding!</p>"},{"location":"initial_setup/","title":"Initial Project Setup","text":"<p>This guide walks you through setting up the FastAPI React Starter project on your local machine. You can choose between the recommended Docker-based setup, using automated scripts, or a manual setup process.</p>"},{"location":"initial_setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following software installed:</p> <ul> <li>Git: For cloning the repository. (Download Git)</li> <li>Docker &amp; Docker Compose (v2): For the recommended Docker-based setup and for running the automated setup scripts. Docker Desktop for Windows and Mac typically includes both. (Download Docker Desktop)<ul> <li>For Linux, you'll need to install Docker Engine and the Docker Compose plugin.</li> </ul> </li> <li>Python (3.10+): Required for manual backend setup. (Download Python)</li> <li>Node.js (LTS version, e.g., 20.x) &amp; npm: Required for manual frontend setup. npm is included with Node.js. (Download Node.js)</li> </ul>"},{"location":"initial_setup/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>First, clone the project repository to your local machine:</p> <pre><code>git clone https://github.com/raythurman2386/fastapi-react-starter.git\ncd fastapi-react-starter\n</code></pre>"},{"location":"initial_setup/#2-environment-configuration","title":"2. Environment Configuration","text":"<p>This project uses <code>.env</code> files for managing environment variables.</p> <ul> <li> <p>For Docker Setup &amp; Automated Scripts:     Create a <code>.env</code> file in the project root directory (<code>fastapi-react-starter/.env</code>). You can copy the example if it exists, or create it with the following content:</p> <p><pre><code># Database Configuration (used by Docker Compose)\nDB_USER=postgres\nDB_PASSWORD=postgres\nDB_NAME=fastapi_db\n</code></pre> Note: The automated setup scripts (<code>setup.ps1</code>, <code>setup.sh</code>) will attempt to create this file from <code>.env.example</code> if present.</p> </li> <li> <p>For Manual Backend Setup:     Create a <code>.env</code> file in the <code>backend</code> directory (<code>fastapi-react-starter/backend/.env</code>):</p> <p><pre><code># Database Configuration\nDB_NAME=fastapi_db\nDB_USER=your_db_user      # Your PostgreSQL username\nDB_PASSWORD=your_db_password  # Your PostgreSQL password\nDB_HOST=localhost\nDB_PORT=5432\n\n# FastAPI Settings\nENVIRONMENT=development\nCORS_ORIGINS=[\"http://localhost:5173\"] # Frontend URL for CORS\n# SECRET_KEY=your_strong_secret_key_here # Generate a strong secret key\n# ALGORITHM=HS256\n# ACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre> Ensure you update database credentials and uncomment/set <code>SECRET_KEY</code>.</p> </li> <li> <p>For Manual Frontend Setup:     The frontend uses Vite, which handles environment variables prefixed with <code>VITE_</code>. The primary variable needed is <code>VITE_API_URL</code> to point to the backend.     Create a <code>.env</code> file in the <code>frontend</code> directory (<code>fastapi-react-starter/frontend/.env</code>):</p> <pre><code>VITE_API_URL=http://localhost:8000\n</code></pre> </li> </ul>"},{"location":"initial_setup/#3-setup-methods","title":"3. Setup Methods","text":"<p>Choose one of the following methods to set up the project:</p>"},{"location":"initial_setup/#method-a-using-docker-recommended","title":"Method A: Using Docker (Recommended)","text":"<p>This is the simplest way to get all services (backend, frontend, database, documentation) up and running.</p> <ol> <li>Ensure Docker Desktop (or Docker Engine + Compose plugin on Linux) is running.</li> <li>Ensure the root <code>.env</code> file is configured as described above.</li> <li> <p>From the project root directory, run:</p> <p><pre><code>docker compose up --build\n</code></pre> To run in detached mode (in the background), add the <code>-d</code> flag: <pre><code>docker compose up --build -d\n</code></pre></p> <p>This command will: *   Build the Docker images for the backend, frontend, and documentation services. *   Start containers for PostgreSQL, backend, frontend, and docs. *   The backend will apply database migrations automatically on startup.</p> </li> </ol>"},{"location":"initial_setup/#method-b-automated-setup-scripts","title":"Method B: Automated Setup Scripts","text":"<p>The project includes scripts to help automate the initial Docker environment setup (checking dependencies and creating the root <code>.env</code> file).</p> <ul> <li> <p>For Windows:</p> <ol> <li>Open PowerShell as Administrator.</li> <li>Navigate to the project root directory.</li> <li>Run the script:     <pre><code>.\\setup.ps1\n</code></pre>     The script will check for Docker Desktop and attempt to install it via <code>winget</code> if not found. It will also create a root <code>.env</code> file from <code>.env.example</code> if available.</li> </ol> </li> <li> <p>For Linux/Mac:</p> <ol> <li>Open your terminal.</li> <li>Navigate to the project root directory.</li> <li>Make the script executable and run it:     <pre><code>chmod +x setup.sh\n./setup.sh\n</code></pre>     The script will check for Docker and attempt to install it using the official convenience script if not found. It also creates the root <code>.env</code> file.</li> </ol> <p>After running the script, proceed with the Docker Compose command as in Method A: <pre><code>docker compose up --build -d\n</code></pre></p> </li> </ul>"},{"location":"initial_setup/#method-c-manual-setup","title":"Method C: Manual Setup","text":"<p>Follow these steps if you prefer to run the backend and frontend services directly on your host machine without Docker.</p> <ol> <li> <p>Backend Setup:</p> <ul> <li>Install PostgreSQL: Install PostgreSQL locally and ensure it's running. Create a database (e.g., <code>fastapi_db</code>) and a user with privileges for this database.</li> <li>Configure <code>backend/.env</code>: Create and configure <code>fastapi-react-starter/backend/.env</code> as described in the \"Environment Configuration\" section, ensuring database credentials match your local PostgreSQL setup.</li> <li>Install Python Dependencies: <pre><code>cd backend\npython -m venv venv  # Create a virtual environment (optional but recommended)\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre></li> <li>Run Database Migrations: <pre><code>python manage.py migrate\n</code></pre></li> <li>Run Backend Server: <pre><code>uvicorn app.main:app --reload --port 8000\n</code></pre></li> </ul> </li> <li> <p>Frontend Setup:</p> <ul> <li>Configure <code>frontend/.env</code>: Create <code>fastapi-react-starter/frontend/.env</code> as described in the \"Environment Configuration\" section, ensuring <code>VITE_API_URL</code> points to your manually running backend (e.g., <code>http://localhost:8000</code>).</li> <li>Install Node.js Dependencies: <pre><code>cd frontend\nnpm install\n</code></pre></li> <li>Run Frontend Development Server: <pre><code>npm run dev\n</code></pre>     This will typically start the frontend on <code>http://localhost:5173</code>.</li> </ul> </li> </ol>"},{"location":"initial_setup/#4-accessing-the-application","title":"4. Accessing the Application","text":"<p>Once the setup is complete and services are running:</p> <ul> <li>Frontend Application: http://localhost:5173</li> <li>Backend API (Swagger UI): http://localhost:8000/docs</li> <li>Project Documentation (if using Docker/docs service): http://localhost:8001</li> </ul>"},{"location":"initial_setup/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Development Guide for information on project structure, coding standards, and common development tasks.</li> <li>If you plan to customize this starter for your own project, check out Make It Yours.</li> </ul>"},{"location":"make_it_yours/","title":"Make It Yours: Customizing the Starter Template","text":"<p>This guide helps you take the FastAPI React Starter template and adapt it into your own unique project.</p>"},{"location":"make_it_yours/#1-introduction","title":"1. Introduction","text":"<p>The FastAPI React Starter is designed to give you a head start with a modern tech stack and a sensible project structure. Follow these steps to rebrand and customize it.</p>"},{"location":"make_it_yours/#2-renaming-the-project","title":"2. Renaming the Project","text":"<p>Consistent naming is key. Here's where to change the project's name:</p> <ul> <li> <p>Root Directory:</p> <ul> <li>Rename the main project folder (e.g., <code>fastapi-react-starter</code> to <code>my-awesome-project</code>).</li> <li>If you've already pushed to a Git remote, you might need to update the remote URL or create a new repository.</li> </ul> </li> <li> <p>**Backend (<code>backend/pyproject.toml</code>):</p> <ul> <li>Update the <code>name</code> under <code>[tool.poetry]</code>:     <pre><code>[tool.poetry]\nname = \"my-awesome-project-backend\"\n# ... other settings\n</code></pre></li> </ul> </li> <li> <p>**Frontend (<code>frontend/package.json</code>):</p> <ul> <li>Update the <code>name</code> field:     <pre><code>{\n  \"name\": \"my-awesome-project-frontend\",\n  // ... other settings\n}\n</code></pre></li> </ul> </li> <li> <p>**Backend Configuration (<code>backend/app/config/config.py</code>):</p> <ul> <li>Change the <code>APP_NAME</code> in the <code>Settings</code> class:     <pre><code>class Settings(BaseSettings):\n    APP_NAME: str = \"My Awesome Project\"\n    # ... other settings\n</code></pre></li> </ul> </li> <li> <p>**Documentation (<code>docs/mkdocs.yml</code>):</p> <ul> <li>Update <code>site_name</code>:     <pre><code>site_name: My Awesome Project Docs\n</code></pre></li> <li>Consider adding/updating <code>site_author</code> and <code>repo_url</code>:     <pre><code>site_author: Your Name or Organization\nrepo_url: https://github.com/your-username/my-awesome-project\nsite_url: https://docs.my-awesome-project.com # If you deploy docs publicly\n</code></pre></li> </ul> </li> <li> <p>**Frontend Title (<code>frontend/index.html</code>):</p> <ul> <li>Update the <code>&lt;title&gt;</code> tag and <code>&lt;meta name=\"description\"&gt;</code>:     <pre><code>&lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;meta name=\"description\" content=\"Description of My Awesome Project.\" /&gt;\n    &lt;title&gt;My Awesome Project&lt;/title&gt;\n&lt;/head&gt;\n</code></pre></li> </ul> </li> </ul>"},{"location":"make_it_yours/#3-customizing-backend-fastapi","title":"3. Customizing Backend (FastAPI)","text":"<ul> <li>Core Logic:<ul> <li>Review and modify/remove existing example routes in <code>backend/app/routes/</code> (e.g., <code>auth.py</code>, <code>health.py</code>).</li> <li>Update or replace schemas in <code>backend/app/schemas/</code>.</li> <li>Adapt or remove services in <code>backend/app/services/</code>.</li> <li>Define your own SQLAlchemy models in <code>backend/app/db/models.py</code> and generate new migrations (see Development Guide).</li> </ul> </li> <li>**Configuration (<code>backend/app/config/config.py</code>):<ul> <li>CRITICAL: Set a new, strong <code>SECRET_KEY</code> (or <code>JWT_SECRET_KEY</code> environment variable) for JWT authentication. Do not use the development default.</li> <li>Adjust <code>CORS_ORIGINS</code> for your frontend's domain(s).</li> <li>Review other settings (database connection, API prefix, etc.).</li> </ul> </li> <li>**Dependencies (<code>backend/requirements.txt</code> or <code>backend/pyproject.toml</code>):<ul> <li>Add, remove, or update Python dependencies based on your project's needs.</li> </ul> </li> </ul>"},{"location":"make_it_yours/#4-customizing-frontend-react","title":"4. Customizing Frontend (React)","text":"<ul> <li>Core Logic &amp; UI:<ul> <li>Review and modify/remove example components in <code>frontend/src/components/</code> and <code>frontend/src/features/</code>.</li> <li>Update routes in <code>frontend/src/App.tsx</code> or <code>frontend/src/routes/</code>.</li> <li>Adapt or remove custom hooks in <code>frontend/src/hooks/</code>.</li> </ul> </li> <li>Styling (Tailwind CSS &amp; shadcn/ui):<ul> <li>Modify <code>frontend/tailwind.config.js</code> to customize your Tailwind theme (colors, fonts, etc.).</li> <li>Adjust global styles in <code>frontend/src/index.css</code> (or equivalent).</li> <li>Customize or replace shadcn/ui components from <code>frontend/src/components/ui/</code>.</li> </ul> </li> <li>Public Assets:<ul> <li>Replace <code>frontend/public/favicon.ico</code> and other icons/logos with your own.</li> <li>Update any static images or assets in <code>frontend/public/</code>.</li> </ul> </li> <li>**Dependencies (<code>frontend/package.json</code>):<ul> <li>Add, remove, or update Node.js dependencies.</li> </ul> </li> </ul>"},{"location":"make_it_yours/#5-docker-configuration-docker-composeyml","title":"5. Docker Configuration (<code>docker-compose.yml</code>)","text":"<ul> <li>Container Names: For clarity, update <code>container_name</code> for each service:     <pre><code>services:\n  postgres:\n    container_name: myproject-db\n    # ...\n  backend:\n    container_name: myproject-backend\n    # ...\n  frontend:\n    container_name: myproject-frontend\n    # ...\n  docs:\n    container_name: myproject-docs\n    # ...\n</code></pre></li> <li>Image Names: If you plan to build and push Docker images to a registry, you'll want to tag them appropriately in your build process (e.g., <code>your-registry/myproject-backend:latest</code>). The <code>build:</code> context in <code>docker-compose.yml</code> defines how images are built locally.</li> </ul>"},{"location":"make_it_yours/#6-documentation","title":"6. Documentation","text":"<ul> <li>Content: Update <code>docs/index.md</code> with your project's overview.</li> <li>Review and modify all other <code>.md</code> files in the <code>docs/</code> directory to reflect your project's specifics, removing or altering template-related information.</li> <li>Configuration (<code>docs/mkdocs.yml</code>): As mentioned in section 2, update <code>site_name</code>, <code>site_author</code>, <code>repo_url</code>, and <code>site_url</code>.</li> </ul>"},{"location":"make_it_yours/#7-license","title":"7. License","text":"<ul> <li>The starter template uses the MIT License. If your project requires a different license, update the <code>LICENSE</code> file in the project root.</li> </ul>"},{"location":"make_it_yours/#8-cleaning-up","title":"8. Cleaning Up","text":"<ul> <li>Search for and remove any template-specific comments, <code>TODO</code> items, or placeholder code that is no longer relevant.</li> <li>Remove or replace example images, SVGs (like <code>frontend/public/starter.svg</code>), and other assets.</li> <li>Ensure all example user accounts, data, or configurations are cleared before deploying to production.</li> </ul> <p>By following these steps, you can effectively transform the FastAPI React Starter template into a solid foundation for your own application.</p>"},{"location":"roadmap/","title":"Project Roadmap","text":"<p>This document outlines the planned features, improvements, and future direction for this project. It's a living document and will evolve as the project progresses.</p>"},{"location":"roadmap/#1-introduction","title":"1. Introduction","text":"<p>Welcome to the project roadmap! This page is intended to provide transparency into our development plans and priorities. If you have ideas or suggestions, please refer to the contributions section.</p>"},{"location":"roadmap/#2-current-status","title":"2. Current Status","text":"<ul> <li>(Example: Initial version launched, based on the FastAPI React Starter template. Core functionalities for X and Y are in place.)</li> <li>(Describe the current state of your project here.)</li> </ul>"},{"location":"roadmap/#3-short-term-goals-next-1-3-months","title":"3. Short-Term Goals (Next 1-3 Months)","text":"<p>These are the key features and improvements we aim to deliver in the near future for this starter template. Users adopting this template should define their own project-specific goals.</p> <ul> <li>Backend Testing:<ul> <li>Description: Implement a comprehensive suite of tests for the FastAPI backend, including unit tests for services and integration tests for API endpoints.</li> <li>Priority: High</li> <li>Status: Planned</li> </ul> </li> <li>Frontend Testing:<ul> <li>Description: Set up testing infrastructure for the React frontend (e.g., using Jest and React Testing Library) and implement initial component and integration tests.</li> <li>Priority: High</li> <li>Status: Planned</li> </ul> </li> <li>Admin Panel and Dashboard:<ul> <li>Description: Investigate and potentially integrate a basic admin panel or dashboard (e.g., using FastAPI Admin or a simple custom frontend section) for managing common administrative tasks.</li> <li>Priority: Medium</li> <li>Status: Planned</li> </ul> </li> <li>Establish Maintenance Processes:<ul> <li>Description: Define and document clear processes for ongoing maintenance, including dependency updates, security patching, and regular code reviews for the template.</li> <li>Priority: Medium</li> <li>Status: Planned</li> </ul> </li> </ul>"},{"location":"roadmap/#6-how-to-contribute-or-suggest-ideas","title":"6. How to Contribute or Suggest Ideas","text":"<p>We actively encourage community feedback, contributions, and feature requests to make this starter template even better!</p> <ul> <li>Bug Reports: If you find a bug, please report it using the GitHub Issues page (replace with your actual repository URL).</li> <li>Feature Requests: Have an idea for a new feature or an improvement to existing functionality? We'd love to hear it! Please submit feature requests via GitHub Issues, clearly labeling it as a feature request.</li> <li>Contributing Code: If you'd like to contribute directly by fixing bugs or implementing new features, please see our Development Guide for setup instructions and contribution guidelines. Fork the repository, make your changes, and submit a pull request.</li> <li>Discussion: For general questions or discussions, consider using GitHub Discussions (if enabled for your repository) or another community channel you set up.</li> </ul>"},{"location":"backend/alembic-migrations/","title":"Database Migrations with Alembic","text":"<p>Alembic is a lightweight database migration tool for SQLAlchemy. It allows you to manage changes to your database schema over time in a structured and version-controlled way.</p>"},{"location":"backend/alembic-migrations/#why-use-alembic","title":"Why Use Alembic?","text":"<ul> <li>Version Control for Your Database: Track schema changes alongside your application code.</li> <li>Repeatable Deployments: Ensure consistent database schemas across different environments (development, staging, production).</li> <li>Collaboration: Makes it easier for multiple developers to work on database schema changes without conflicts.</li> <li>Automated Schema Changes: Avoids manual SQL scripting for schema modifications, reducing errors.</li> </ul>"},{"location":"backend/alembic-migrations/#core-concepts","title":"Core Concepts","text":"<ul> <li>Migration Environment: A directory (usually named <code>alembic</code> or <code>alembic</code> in your backend root) containing Alembic's configuration and migration scripts.</li> <li><code>alembic.ini</code>: The main configuration file for Alembic. It specifies database connection details, script locations, and other settings.</li> <li><code>env.py</code>: A Python script within the migration environment that Alembic executes when running commands. It's where you configure how Alembic connects to your database and how it discovers your SQLAlchemy models for autogeneration.<ul> <li>Crucially, <code>env.py</code> needs to know about your SQLAlchemy models' metadata (<code>target_metadata = Base.metadata</code>).</li> </ul> </li> <li>Revision: A single migration script representing a set of changes to the database schema. Each revision has a unique ID.</li> <li><code>upgrade()</code> function: Contains the operations to apply the schema changes (e.g., create a table, add a column).</li> <li><code>downgrade()</code> function: Contains the operations to revert the schema changes.</li> </ul>"},{"location":"backend/alembic-migrations/#setting-up-alembic-if-not-already-set-up","title":"Setting Up Alembic (If not already set up)","text":"<p>If Alembic is not yet part of the project, you would typically initialize it:</p> <ol> <li>Install Alembic: <code>pip install alembic</code></li> <li>Initialize the environment (from your <code>backend</code> directory):     <pre><code>alembic init alembic\n</code></pre>     (This creates a <code>alembic</code> directory and an <code>alembic.ini</code> file.)</li> <li>Configure <code>alembic.ini</code> with your database URL (<code>sqlalchemy.url</code>).</li> <li>Configure <code>alembic/env.py</code>:<ul> <li>Ensure <code>target_metadata</code> points to your SQLAlchemy <code>Base.metadata</code> from <code>app.db.base</code> or wherever your models are defined.</li> <li>Ensure the Python path is set up so <code>env.py</code> can import your application modules.</li> </ul> </li> </ol>"},{"location":"backend/alembic-migrations/#common-alembic-commands","title":"Common Alembic Commands","text":"<p>Run these commands from the directory containing <code>alembic.ini</code> (usually your <code>backend</code> root).</p>"},{"location":"backend/alembic-migrations/#1-generating-a-new-migration-script","title":"1. Generating a New Migration Script","text":"<p>When you make changes to your SQLAlchemy models (e.g., add a new model, add a column to an existing model), you need to generate a migration script.</p> <p>Manual Revision (Recommended for understanding): <pre><code>alembic revision -m \"create_users_table\"\n</code></pre> This creates a new, empty migration file in <code>alembic/versions/</code>. You then manually edit this file to define the <code>upgrade()</code> and <code>downgrade()</code> functions using Alembic's <code>op</code> object.</p> <p>Example (Manual - creating a users table): <pre><code># In the generated migration_xyz.py file\nfrom alembic import op\nimport sqlalchemy as sa\n\n# revision identifiers, used by Alembic.\nrevision = 'your_revision_id'\ndown_revision = 'previous_revision_id_or_None'\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    op.create_table(\n        'users',\n        sa.Column('id', sa.Integer, primary_key=True, index=True),\n        sa.Column('email', sa.String, unique=True, index=True, nullable=False),\n        sa.Column('hashed_password', sa.String, nullable=False),\n        sa.Column('is_active', sa.Boolean, default=True)\n    )\n\ndef downgrade():\n    op.drop_table('users')\n</code></pre></p> <p>Autogenerate Revision (Use with caution and always review): Alembic can compare your SQLAlchemy models against the current database state and attempt to generate the migration script automatically.</p> <p><pre><code>alembic revision -m \"add_bio_to_users\" --autogenerate\n</code></pre> *   Important: Always review autogenerated scripts carefully. Alembic might not detect all changes perfectly (e.g., complex constraints, server defaults, changes to types that are not straightforward). You might need to manually adjust the script.</p>"},{"location":"backend/alembic-migrations/#2-applying-migrations","title":"2. Applying Migrations","text":"<p>To apply pending migrations to your database:</p> <ul> <li>Apply all pending migrations (upgrade to the latest revision): <pre><code>alembic upgrade head\n</code></pre></li> <li>Apply migrations up to a specific revision: <pre><code>alembic upgrade &lt;revision_id&gt;\n</code></pre></li> <li>Apply a single next migration: <pre><code>alembic upgrade +1\n</code></pre></li> </ul>"},{"location":"backend/alembic-migrations/#3-reverting-migrations-downgrading","title":"3. Reverting Migrations (Downgrading)","text":"<p>To undo migrations:</p> <ul> <li>Revert the last applied migration: <pre><code>alembic downgrade -1\n</code></pre></li> <li>Revert migrations down to a specific revision: <pre><code>alembic downgrade &lt;target_revision_id&gt;\n</code></pre></li> <li>Revert all migrations (to an empty database state, if applicable): <pre><code>alembic downgrade base\n</code></pre> (Use with extreme caution on production data!)</li> </ul>"},{"location":"backend/alembic-migrations/#4-viewing-migration-status","title":"4. Viewing Migration Status","text":"<ul> <li>Show current revision(s) and migration history: <pre><code>alembic history\n</code></pre></li> <li>Show the current revision ID(s) the database is at: <pre><code>alembic current\n</code></pre></li> <li>Show all revisions, indicating which are applied: <pre><code>alembic history --verbose\n</code></pre></li> </ul>"},{"location":"backend/alembic-migrations/#best-practices","title":"Best Practices","text":"<ul> <li>Keep Migrations Small and Focused: Each migration should represent a single, logical change.</li> <li>Test Migrations: Always test your migrations in a development or staging environment before applying them to production.</li> <li>Never Edit an Applied Migration: Once a migration has been applied to a shared database (like production), do not edit its script. Instead, create a new migration to correct or alter it.</li> <li>Backup Your Database: Before running significant migrations on production, always back up your database.</li> <li>Review Autogenerated Scripts: Thoroughly inspect any script generated with <code>--autogenerate</code>.</li> <li>Consider Data Migrations Separately: For changes that involve transforming data (not just schema), you might write custom Python code within your migration script or handle it as a separate process. Alembic's <code>op.bulk_insert</code> and <code>op.execute</code> can be useful here.</li> </ul>"},{"location":"backend/alembic-migrations/#further-reading","title":"Further Reading","text":"<ul> <li>Alembic Official Tutorial</li> <li>Alembic Operation Reference</li> </ul>"},{"location":"backend/fastapi-guide/","title":"FastAPI Guide for Backend Development","text":"<p>This guide provides an overview of how FastAPI is used in this project and key concepts for backend development.</p>"},{"location":"backend/fastapi-guide/#why-fastapi","title":"Why FastAPI?","text":"<p>FastAPI is a modern, high-performance web framework for building APIs with Python 3.7+ based on standard Python type hints. Key benefits include:</p> <ul> <li>High Performance: On par with NodeJS and Go, thanks to Starlette and Pydantic.</li> <li>Fast to Code: Increase the speed to develop features by about 200% to 300%.</li> <li>Fewer Bugs: Reduce about 40% of human-induced errors (thanks to type hints).</li> <li>Intuitive: Great editor support. Completion everywhere. Less time debugging.</li> <li>Easy: Designed to be easy to use and learn. Less time reading docs.</li> <li>Short: Minimize code duplication. Multiple features from each parameter declaration.</li> <li>Robust: Get production-ready code. With automatic interactive documentation.</li> <li>Standards-based: Based on (and fully compatible with) the open standards for APIs: OpenAPI and JSON Schema.</li> </ul>"},{"location":"backend/fastapi-guide/#backend-project-structure","title":"Backend Project Structure","text":"<p>Our backend is organized to promote modularity and maintainability. A typical structure (located in <code>backend/app/</code>) might look like this:</p> <pre><code>backend/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 config/           # Configuration settings (from .env)\n\u2502   \u251c\u2500\u2500 db/               # Database models and sessions\n\u2502   \u251c\u2500\u2500 logs/           # Log files\n\u2502   \u251c\u2500\u2500 routes/           # API routes and endpoints\n\u2502   \u251c\u2500\u2500 schemas/          # Pydantic schemas (data validation)\n\u2502   \u251c\u2500\u2500 services/         # Business logic services\n\u2502   \u251c\u2500\u2500 utils/            # Utility functions and constants\n\u2502   \u2514\u2500\u2500 main.py           # FastAPI application instance and main router\n\u251c\u2500\u2500 alembic/           # Alembic migrations (if using Alembic)\n\u251c\u2500\u2500 tests/                # Unit and integration tests\n\u251c\u2500\u2500 .env.example          # Example environment variables\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 alembic.ini           # Alembic configuration (if used)\n\u251c\u2500\u2500 Dockerfile            # Dockerfile for containerization\n\u251c\u2500\u2500 pyproject.toml        # pyproject.toml for Poetry\n\u251c\u2500\u2500 README.md             # This file\n\u2514\u2500\u2500 requirements.txt      # Project dependencies \n</code></pre>"},{"location":"backend/fastapi-guide/#defining-endpoints","title":"Defining Endpoints","text":"<p>Endpoints are defined using path operation decorators (<code>@router.get</code>, <code>@router.post</code>, etc.) on functions within modules in <code>app/api/v1/endpoints/</code>. These routers are then included in the main FastAPI app instance in <code>app/main.py</code>.</p> <p>Example (<code>app/api/v1/endpoints/items.py</code>): <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom app import crud, schemas\nfrom app.api.v1 import deps # Assuming deps.py for get_db\n\nrouter = APIRouter()\n\n@router.post(\"/items/\", response_model=schemas.Item)\ndef create_item(item: schemas.ItemCreate, db: Session = Depends(deps.get_db)):\n    return crud.item.create(db=db, item=item)\n\n@router.get(\"/items/{item_id}\", response_model=schemas.Item)\ndef read_item(item_id: int, db: Session = Depends(deps.get_db)):\n    db_item = crud.item.get(db, id=item_id)\n    if db_item is None:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return db_item\n</code></pre></p>"},{"location":"backend/fastapi-guide/#data-validation-with-pydantic","title":"Data Validation with Pydantic","text":"<p>Pydantic is used extensively for data validation, serialization, and settings management.</p> <ul> <li>Request Bodies: Define a Pydantic model (schema) that inherits from <code>BaseModel</code>. FastAPI will automatically validate incoming request data against this schema.</li> <li>Response Models: Use the <code>response_model</code> parameter in path operation decorators to define the schema for the response. FastAPI will filter and serialize the output data to match this schema.</li> <li>Path and Query Parameters: Type hints for path and query parameters are also validated.</li> </ul> <p>Example (<code>app/schemas/item.py</code>): <pre><code>from pydantic import BaseModel\n\nclass ItemBase(BaseModel):\n    title: str\n    description: str | None = None\n\nclass ItemCreate(ItemBase):\n    pass\n\nclass Item(ItemBase):\n    id: int\n    owner_id: int\n\n    class Config:\n        orm_mode = True # or from_attributes = True for Pydantic v2\n</code></pre></p>"},{"location":"backend/fastapi-guide/#dependency-injection","title":"Dependency Injection","text":"<p>FastAPI's dependency injection system is a powerful feature used for:</p> <ul> <li>Database Sessions: Providing a database session to path operation functions (e.g., <code>db: Session = Depends(deps.get_db)</code>).</li> <li>Authentication &amp; Authorization: Getting the current user or validating security scopes (e.g., <code>current_user: models.User = Depends(deps.get_current_active_user)</code>).</li> <li>Shared Logic: Reusing common logic or parameters.</li> </ul> <p>Dependencies are defined as functions (often in <code>app/api/v1/deps.py</code>) that FastAPI will call.</p>"},{"location":"backend/fastapi-guide/#asynchronous-operations-asyncawait","title":"Asynchronous Operations (<code>async</code>/<code>await</code>)","text":"<p>FastAPI supports asynchronous path operation functions using <code>async def</code>. This is crucial for I/O-bound operations (like database calls or external API requests) to prevent blocking the server.</p> <p><pre><code>@router.get(\"/async-items/\")\nasync def read_async_items():\n    # Example: await some_async_io_operation()\n    return [{\"name\": \"Async Item 1\"}, {\"name\": \"Async Item 2\"}]\n</code></pre> Ensure your database drivers and other I/O libraries support <code>async</code> operations (e.g., <code>asyncpg</code> for PostgreSQL with SQLAlchemy).</p>"},{"location":"backend/fastapi-guide/#authentication","title":"Authentication","text":"<p>This project typically uses JWT (JSON Web Tokens) for authentication. The flow usually involves: 1.  An endpoint (e.g., <code>/login/access-token</code>) where users submit credentials. 2.  If valid, the server generates and returns an access token. 3.  The client includes this token in the <code>Authorization</code> header (e.g., <code>Bearer &lt;token&gt;</code>) for subsequent requests to protected endpoints. 4.  A dependency (<code>get_current_user</code>) validates the token and retrieves the user.</p> <p>Security utilities for password hashing and JWT management are often in <code>app/core/security.py</code>.</p>"},{"location":"backend/fastapi-guide/#automatic-api-documentation","title":"Automatic API Documentation","text":"<p>FastAPI automatically generates interactive API documentation based on your code, Pydantic models, and OpenAPI schema.</p> <ul> <li>Swagger UI: Accessible at <code>/docs</code> (e.g., <code>http://localhost:8000/docs</code>).</li> <li>ReDoc: Accessible at <code>/redoc</code> (e.g., <code>http://localhost:8000/redoc</code>).</li> </ul> <p>This documentation is invaluable for frontend developers and API consumers.</p>"},{"location":"backend/fastapi-guide/#further-reading","title":"Further Reading","text":"<ul> <li>FastAPI Official Tutorial</li> <li>Pydantic Documentation</li> </ul>"},{"location":"frontend/shadcn-ui/","title":"Shadcn UI Guide","text":"<p>This project leverages Shadcn UI for building its user interface. Shadcn UI is not a traditional component library but rather a collection of beautifully designed components that you can copy and paste into your application. This approach gives you full ownership and control over the code, allowing for deep customization.</p>"},{"location":"frontend/shadcn-ui/#philosophy","title":"Philosophy","text":"<p>Understanding the philosophy behind Shadcn UI is key to using it effectively:</p> <ul> <li>You Own the Code: When you add a component, its source code is added directly to your project (typically under <code>frontend/src/components/ui/</code>). You can modify it as much as you need.</li> <li>Not a Dependency: It's not a package you install from npm in the usual sense (apart from the CLI tool). This means no versioning conflicts with a third-party library and no waiting for the library maintainer to update or fix something.</li> <li>Built with Radix UI and Tailwind CSS: Components are generally built using Radix UI Primitives for accessibility and behavior, and styled with Tailwind CSS for a utility-first approach.</li> </ul>"},{"location":"frontend/shadcn-ui/#adding-components","title":"Adding Components","text":"<p>To add new components to your project, use the Shadcn UI CLI. Make sure you are in the <code>frontend</code> directory:</p> <pre><code>npx shadcn-ui@latest add [component-name]\n</code></pre> <p>For example, to add an <code>alert-dialog</code>:</p> <pre><code>npx shadcn-ui@latest add alert-dialog\n</code></pre> <p>This command will typically do the following: 1.  Check your <code>components.json</code> for configuration. 2.  Install any necessary dependencies for the component (e.g., <code>@radix-ui/react-alert-dialog</code>). 3.  Add the component's source code to <code>frontend/src/components/ui/</code>.</p>"},{"location":"frontend/shadcn-ui/#configuration-componentsjson","title":"Configuration (<code>components.json</code>)","text":"<p>The behavior of the Shadcn UI CLI is configured by the <code>components.json</code> file located in your <code>frontend</code> directory. This file defines:</p> <ul> <li><code>$schema</code>: The schema URL for <code>components.json</code>.</li> <li><code>style</code>: The style of components to use (e.g., \"default\", \"new-york\"). This template uses <code>default</code>.</li> <li><code>rsc</code>: Whether to install React Server Components (RSC) compatible components (true/false).</li> <li><code>tsx</code>: Whether to use TypeScript for components (true/false). This template uses <code>true</code>.</li> <li><code>tailwind</code>:<ul> <li><code>config</code>: Path to your Tailwind CSS configuration file.</li> <li><code>css</code>: Path to your main CSS file where Tailwind directives are imported.</li> <li><code>baseColor</code>: The base color for your theme (e.g., \"slate\", \"zinc\").</li> <li><code>cssVariables</code>: Whether to use CSS variables for theming.</li> </ul> </li> <li><code>aliases</code>:<ul> <li><code>components</code>: Path alias for where your UI components are stored (e.g., <code>~/components</code>, which might map to <code>src/components</code>).</li> <li><code>utils</code>: Path alias for utility functions (e.g., <code>~/lib/utils</code> for <code>cn()</code> function).</li> </ul> </li> </ul> <p>Ensure this file is configured correctly for your project structure if you deviate from the template's defaults.</p>"},{"location":"frontend/shadcn-ui/#customizing-components","title":"Customizing Components","text":"<p>Since the component code is directly in your project (e.g., <code>frontend/src/components/ui/button.tsx</code>), you can customize it by:</p> <ul> <li>Modifying Styles: Directly change Tailwind CSS classes within the component's TSX file.</li> <li>Altering Behavior: Change the underlying Radix UI primitives or add your own logic.</li> <li>Extending Functionality: Add new props or features to the component.</li> </ul>"},{"location":"frontend/shadcn-ui/#theming","title":"Theming","text":"<p>Shadcn UI components are designed to be themed using CSS variables. Check the <code>frontend/src/index.css</code> (or your main CSS file) for the theme variables defined by Shadcn UI when you initialized it. You can customize these variables to change the overall look and feel of the components.</p>"},{"location":"frontend/shadcn-ui/#best-practices","title":"Best Practices","text":"<ul> <li>Keep CLI Updated: Occasionally run <code>npx shadcn-ui@latest init</code> to ensure your CLI and local setup are up-to-date with any changes from Shadcn UI (be careful and review changes if you have heavily customized <code>components.json</code>).</li> <li>Refer to Official Docs: For specific component APIs, props, and usage examples, always refer to the official Shadcn UI documentation.</li> <li>Understand Dependencies: When you add a component, it might install peer dependencies (like Radix UI packages). Be aware of these in your <code>package.json</code>.</li> </ul> <p>By following this guide and leveraging the official documentation, you can effectively use Shadcn UI to build a beautiful and highly customizable frontend for this application.</p>"},{"location":"frontend/tailwind-v4/","title":"Tailwind CSS v4 Integration","text":"<p>This project utilizes Tailwind CSS v4, the latest iteration of the utility-first CSS framework. Version 4 brings significant improvements in performance, a new engine, and a more streamlined developer experience, designed for the modern web.</p>"},{"location":"frontend/tailwind-v4/#key-features-changes-from-v3","title":"Key Features &amp; Changes from v3","text":"<p>While a comprehensive list of changes can be found in the official Tailwind CSS v4 documentation, here are some highlights relevant to users of this template:</p> <ul> <li>New Engine (Oxide): Tailwind CSS v4 features a new, high-performance engine written in Rust, leading to faster build times and a more responsive development experience.</li> <li>Simplified Configuration: The configuration file (<code>tailwind.config.js</code> or <code>tailwind.config.ts</code>) might look different, with a more CSS-first approach. Many common customizations are now handled more intuitively.</li> <li>Automatic Content Detection: In many cases, explicit content path configuration is less critical due to smarter defaults.</li> <li>First-Party Vite Plugin: Integration with Vite is smoother with the official <code>@tailwindcss/vite</code> plugin.</li> <li>Modern CSS Features: v4 embraces modern CSS capabilities like cascade layers, container queries, and wide-gamut P3 colors more natively.</li> </ul>"},{"location":"frontend/tailwind-v4/#modern-browser-requirements","title":"Modern Browser Requirements","text":"<p>It's important to note that Tailwind CSS v4 is designed for modern browser environments. If you need to support older browsers, you might consider using Tailwind CSS v3.4 or implementing appropriate polyfills.</p> <p>Tailwind CSS v4 officially supports:</p> <ul> <li>Safari 16.4+</li> <li>Chrome 111+</li> <li>Firefox 128+</li> </ul> <p>Ensure your target audience aligns with these browser versions.</p>"},{"location":"frontend/tailwind-v4/#using-tailwind-css-in-this-project","title":"Using Tailwind CSS in This Project","text":"<ul> <li>Configuration: The Tailwind CSS configuration is located at <code>frontend/tailwind.config.js</code> (or <code>.ts</code>).</li> <li>Utility Classes: Continue to use Tailwind's utility classes directly in your React components (TSX/JSX files) as you normally would.</li> <li>Base Styles: Global styles, custom base styles, or component layers can be defined in <code>frontend/src/index.css</code> (or your main CSS entry point).</li> </ul>"},{"location":"frontend/tailwind-v4/#upgrading-from-v3-general-advice","title":"Upgrading from v3 (General Advice)","text":"<p>If you were previously using Tailwind CSS v3 and are adapting to this v4 template, or if you're upgrading another project, refer to the official Tailwind CSS v4 Upgrade Guide.</p>"},{"location":"frontend/tailwind-v4/#further-information","title":"Further Information","text":"<p>For the most detailed and up-to-date information, always refer to the official Tailwind CSS v4 Documentation.</p>"}]}